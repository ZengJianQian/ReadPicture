"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _pick2 = _interopRequireDefault(require("lodash/pick"));
var _isNull2 = _interopRequireDefault(require("lodash/isNull"));
var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));
var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));
var _get2 = _interopRequireDefault(require("lodash/get"));
var _noop2 = _interopRequireDefault(require("lodash/noop"));
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _isString2 = _interopRequireDefault(require("lodash/isString"));
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _classnames = _interopRequireDefault(require("classnames"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/treeSelect/foundation"));
var _treeUtil = require("@douyinfe/semi-foundation/lib/cjs/tree/treeUtil");
var _constants = require("@douyinfe/semi-foundation/lib/cjs/treeSelect/constants");
var _constants2 = require("@douyinfe/semi-foundation/lib/cjs/popover/constants");
var _reactWindow = require("react-window");
require("@douyinfe/semi-foundation/lib/cjs/tree/tree.css");
require("@douyinfe/semi-foundation/lib/cjs/treeSelect/treeSelect.css");
var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));
var _context = _interopRequireDefault(require("../configProvider/context"));
var _group = _interopRequireDefault(require("../tag/group"));
var _index = _interopRequireDefault(require("../tag/index"));
var _index2 = _interopRequireDefault(require("../input/index"));
var _autoSizer = _interopRequireDefault(require("../tree/autoSizer"));
var _treeContext = _interopRequireDefault(require("../tree/treeContext"));
var _treeNode = _interopRequireDefault(require("../tree/treeNode"));
var _nodeList = _interopRequireDefault(require("../tree/nodeList"));
var _treeUtil2 = require("../tree/treeUtil");
var _localeConsumer = _interopRequireDefault(require("../locale/localeConsumer"));
var _trigger = _interopRequireDefault(require("../trigger"));
var _tagInput = _interopRequireDefault(require("../tagInput"));
var _utils = require("../_utils");
var _semiIcons = require("@douyinfe/semi-icons");
var _checkboxGroup = _interopRequireDefault(require("../checkbox/checkboxGroup"));
var _index3 = _interopRequireDefault(require("../popover/index"));
var _virtualRow = _interopRequireDefault(require("../select/virtualRow"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
const prefixcls = _constants.cssClasses.PREFIX;
const prefixTree = _constants.cssClasses.PREFIX_TREE;
const key = 0;
class TreeSelect extends _baseComponent.default {
  constructor(props) {
    super(props);
    this.renderSuffix = () => {
      const {
        suffix
      } = this.props;
      const suffixWrapperCls = (0, _classnames.default)({
        [`${prefixcls}-suffix`]: true,
        [`${prefixcls}-suffix-text`]: suffix && (0, _isString2.default)(suffix),
        [`${prefixcls}-suffix-icon`]: (0, _utils.isSemiIcon)(suffix)
      });
      return /*#__PURE__*/_react.default.createElement("div", {
        className: suffixWrapperCls,
        "x-semi-prop": "suffix"
      }, suffix);
    };
    this.renderPrefix = () => {
      const {
        prefix,
        insetLabel,
        insetLabelId
      } = this.props;
      const labelNode = prefix || insetLabel;
      const prefixWrapperCls = (0, _classnames.default)({
        [`${prefixcls}-prefix`]: true,
        // to be doublechecked
        [`${prefixcls}-inset-label`]: insetLabel,
        [`${prefixcls}-prefix-text`]: labelNode && (0, _isString2.default)(labelNode),
        [`${prefixcls}-prefix-icon`]: (0, _utils.isSemiIcon)(labelNode)
      });
      return /*#__PURE__*/_react.default.createElement("div", {
        className: prefixWrapperCls,
        id: insetLabelId,
        "x-semi-prop": "prefix,insetLabel"
      }, labelNode);
    };
    this.renderContent = () => {
      const {
        dropdownMinWidth
      } = this.state;
      const {
        dropdownStyle,
        dropdownClassName
      } = this.props;
      const style = Object.assign({
        minWidth: dropdownMinWidth
      }, dropdownStyle);
      const popoverCls = (0, _classnames.default)(dropdownClassName, `${prefixcls}-popover`);
      return /*#__PURE__*/_react.default.createElement("div", {
        className: popoverCls,
        style: style,
        onKeyDown: this.foundation.handleKeyDown
      }, this.renderTree());
    };
    this.removeTag = removedKey => {
      this.foundation.removeTag(removedKey);
    };
    this.handleClick = e => {
      this.foundation.handleClick(e);
    };
    this.getDataForKeyNotInKeyEntities = key => {
      return this.foundation.getDataForKeyNotInKeyEntities(key);
    };
    /* istanbul ignore next */
    this.handleSelectionEnterPress = e => {
      this.foundation.handleSelectionEnterPress(e);
    };
    this.hasValue = () => {
      const {
        multiple,
        checkRelation
      } = this.props;
      const {
        realCheckedKeys,
        checkedKeys,
        selectedKeys
      } = this.state;
      let hasValue = false;
      if (multiple) {
        if (checkRelation === 'related') {
          hasValue = Boolean(checkedKeys.size);
        } else if (checkRelation === 'unRelated') {
          hasValue = Boolean(realCheckedKeys.size);
        }
      } else {
        hasValue = Boolean(selectedKeys.length);
      }
      return hasValue;
    };
    this.showClearBtn = () => {
      const {
        showClear,
        disabled,
        searchPosition
      } = this.props;
      const {
        inputValue,
        isOpen,
        isHovering
      } = this.state;
      const triggerSearchHasInputValue = searchPosition === _constants.strings.SEARCH_POSITION_TRIGGER && inputValue;
      return showClear && (this.hasValue() || triggerSearchHasInputValue) && !disabled && (isOpen || isHovering);
    };
    this.renderTagList = triggerRenderKeys => {
      const {
        keyEntities,
        disabledKeys
      } = this.state;
      const {
        treeNodeLabelProp,
        leafOnly,
        disabled,
        disableStrictly,
        size,
        renderSelectedItem: propRenderSelectedItem,
        keyMaps
      } = this.props;
      const realLabelName = (0, _get2.default)(keyMaps, 'label', treeNodeLabelProp);
      const renderSelectedItem = (0, _isFunction2.default)(propRenderSelectedItem) ? propRenderSelectedItem : item => ({
        isRenderInTag: true,
        content: (0, _get2.default)(item, realLabelName, null)
      });
      const tagList = [];
      triggerRenderKeys.forEach((key, index) => {
        const item = keyEntities[key] && keyEntities[key].key === key ? keyEntities[key].data : this.getDataForKeyNotInKeyEntities(key);
        const onClose = (tagContent, e) => {
          if (e && typeof e.preventDefault === 'function') {
            // make sure that tag will not hidden immediately in controlled mode
            e.preventDefault();
          }
          this.removeTag(key);
        };
        const {
          content,
          isRenderInTag
        } = item ? renderSelectedItem(item, {
          index,
          onClose
        }) : {};
        if ((0, _isNull2.default)(content) || (0, _isUndefined2.default)(content)) {
          return;
        }
        const isDisabled = disabled || item.disabled || disableStrictly && disabledKeys.has(item.key);
        const tag = {
          closable: !isDisabled,
          color: 'white',
          visible: true,
          onClose,
          key: `tag-${key}-${index}`,
          size: size === 'small' ? 'small' : 'large'
        };
        if (isRenderInTag) {
          // pass ReactNode list to tagList when using tagGroup custom mode
          tagList.push(/*#__PURE__*/_react.default.createElement(_index.default, Object.assign({}, tag), content));
        } else {
          tagList.push(content);
        }
      });
      return tagList;
    };
    /**
     * When single selection and the search box is on trigger, the items displayed in the rendered search box
     */
    this.renderSingleTriggerSearchItem = () => {
      const {
        placeholder,
        disabled
      } = this.props;
      const {
        inputTriggerFocus
      } = this.state;
      const renderText = this.foundation.getRenderTextInSingle();
      const spanCls = (0, _classnames.default)(`${prefixcls}-selection-TriggerSearchItem`, {
        [`${prefixcls}-selection-TriggerSearchItem-placeholder`]: (inputTriggerFocus || !renderText) && !disabled,
        [`${prefixcls}-selection-TriggerSearchItem-disabled`]: disabled
      });
      return /*#__PURE__*/_react.default.createElement("span", {
        className: spanCls,
        onClick: this.foundation.onClickSingleTriggerSearchItem
      }, renderText ? renderText : placeholder);
    };
    /**
     * Single selection and the search box content rendered when the search box is on trigger
     */
    this.renderSingleTriggerSearch = () => {
      const {
        inputValue
      } = this.state;
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, this.renderInput(), !inputValue && this.renderSingleTriggerSearchItem());
    };
    this.renderSelectContent = triggerRenderKeys => {
      const {
        multiple,
        placeholder,
        maxTagCount,
        searchPosition,
        filterTreeNode,
        showRestTagsPopover,
        restTagsPopoverProps
      } = this.props;
      const isTriggerPositionSearch = filterTreeNode && searchPosition === _constants.strings.SEARCH_POSITION_TRIGGER;
      // searchPosition = trigger
      if (isTriggerPositionSearch) {
        return multiple ? this.renderTagInput(triggerRenderKeys) : this.renderSingleTriggerSearch();
      }
      // searchPosition = dropdown and single seleciton
      if (!multiple || !this.hasValue()) {
        const renderText = this.foundation.getRenderTextInSingle();
        const spanCls = (0, _classnames.default)(`${prefixcls}-selection-content`, {
          [`${prefixcls}-selection-placeholder`]: !renderText
        });
        return /*#__PURE__*/_react.default.createElement("span", {
          className: spanCls
        }, renderText ? renderText : placeholder);
      }
      // searchPosition = dropdown and multiple seleciton
      const tagList = this.renderTagList(triggerRenderKeys);
      // mode=custom to return tagList directly
      return /*#__PURE__*/_react.default.createElement(_group.default, {
        maxTagCount: maxTagCount,
        tagList: tagList,
        size: "large",
        mode: "custom",
        showPopover: showRestTagsPopover,
        popoverProps: restTagsPopoverProps
      });
    };
    this.handleClear = e => {
      e && e.stopPropagation();
      this.foundation.handleClear(e);
    };
    /* istanbul ignore next */
    this.handleClearEnterPress = e => {
      e && e.stopPropagation();
      this.foundation.handleClearEnterPress(e);
    };
    this.handleMouseOver = e => {
      this.foundation.toggleHoverState(true);
    };
    this.handleMouseLeave = e => {
      this.foundation.toggleHoverState(false);
    };
    this.search = value => {
      const {
        isOpen
      } = this.state;
      if (!isOpen) {
        this.foundation.open();
      }
      this.foundation.handleInputChange(value);
    };
    this.close = () => {
      this.foundation.close(null);
    };
    this.renderArrow = () => {
      const showClearBtn = this.showClearBtn();
      const {
        arrowIcon
      } = this.props;
      if (showClearBtn) {
        return null;
      }
      return arrowIcon ? (/*#__PURE__*/_react.default.createElement("div", {
        className: (0, _classnames.default)(`${prefixcls}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, arrowIcon)) : null;
    };
    this.renderClearBtn = () => {
      const showClearBtn = this.showClearBtn();
      const {
        clearIcon
      } = this.props;
      const clearCls = (0, _classnames.default)(`${prefixcls}-clearbtn`);
      if (showClearBtn) {
        return /*#__PURE__*/_react.default.createElement("div", {
          role: 'button',
          tabIndex: 0,
          "aria-label": "Clear TreeSelect value",
          className: clearCls,
          onClick: this.handleClear,
          onKeyPress: this.handleClearEnterPress
        }, clearIcon ? clearIcon : /*#__PURE__*/_react.default.createElement(_semiIcons.IconClear, null));
      }
      return null;
    };
    this.renderSelection = () => {
      const _a = this.props,
        {
          disabled,
          multiple,
          filterTreeNode,
          validateStatus,
          prefix,
          suffix,
          style,
          size,
          insetLabel,
          className,
          placeholder,
          showClear,
          leafOnly,
          searchPosition,
          triggerRender,
          borderless,
          autoMergeValue,
          checkRelation
        } = _a,
        rest = __rest(_a, ["disabled", "multiple", "filterTreeNode", "validateStatus", "prefix", "suffix", "style", "size", "insetLabel", "className", "placeholder", "showClear", "leafOnly", "searchPosition", "triggerRender", "borderless", "autoMergeValue", "checkRelation"]);
      const {
        inputValue,
        selectedKeys,
        checkedKeys,
        keyEntities,
        isFocus,
        realCheckedKeys
      } = this.state;
      const filterable = Boolean(filterTreeNode);
      const useCustomTrigger = typeof triggerRender === 'function';
      const mouseEvent = showClear ? {
        onMouseEnter: e => this.handleMouseOver(e),
        onMouseLeave: e => this.handleMouseLeave(e)
      } : {};
      const isTriggerPositionSearch = searchPosition === _constants.strings.SEARCH_POSITION_TRIGGER && filterable;
      const isEmptyTriggerSearch = isTriggerPositionSearch && (0, _isEmpty2.default)(checkedKeys);
      const isValueTriggerSearch = isTriggerPositionSearch && !(0, _isEmpty2.default)(checkedKeys);
      const classNames = useCustomTrigger ? (0, _classnames.default)(className) : (0, _classnames.default)(prefixcls, {
        [`${prefixcls}-borderless`]: borderless,
        [`${prefixcls}-focus`]: isFocus,
        [`${prefixcls}-disabled`]: disabled,
        [`${prefixcls}-single`]: !multiple,
        [`${prefixcls}-multiple`]: multiple,
        [`${prefixcls}-multiple-tagInput-empty`]: multiple && isEmptyTriggerSearch,
        [`${prefixcls}-multiple-tagInput-notEmpty`]: multiple && isValueTriggerSearch,
        [`${prefixcls}-filterable`]: filterable,
        [`${prefixcls}-error`]: validateStatus === 'error',
        [`${prefixcls}-warning`]: validateStatus === 'warning',
        [`${prefixcls}-small`]: size === 'small',
        [`${prefixcls}-large`]: size === 'large',
        [`${prefixcls}-with-prefix`]: prefix || insetLabel,
        [`${prefixcls}-with-suffix`]: suffix,
        [`${prefixcls}-with-suffix`]: suffix
      }, className);
      let inner;
      let triggerRenderKeys = [];
      if (multiple) {
        if (!autoMergeValue) {
          triggerRenderKeys = [...checkedKeys];
        } else if (checkRelation === 'related') {
          triggerRenderKeys = (0, _treeUtil.normalizeKeyList)([...checkedKeys], keyEntities, leafOnly, true);
        } else if (checkRelation === 'unRelated') {
          triggerRenderKeys = [...realCheckedKeys];
        }
      } else {
        triggerRenderKeys = selectedKeys;
      }
      if (useCustomTrigger) {
        inner = /*#__PURE__*/_react.default.createElement(_trigger.default, {
          inputValue: inputValue,
          value: triggerRenderKeys.map(key => (0, _get2.default)(keyEntities, [key, 'data'])),
          disabled: disabled,
          placeholder: placeholder,
          onClear: this.handleClear,
          componentName: 'TreeSelect',
          triggerRender: triggerRender,
          componentProps: Object.assign({}, this.props),
          onSearch: this.search,
          onRemove: this.removeTag
        });
      } else {
        inner = [/*#__PURE__*/_react.default.createElement(_react.Fragment, {
          key: 'prefix'
        }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
          key: 'selection'
        }, /*#__PURE__*/_react.default.createElement("div", {
          className: `${prefixcls}-selection`
        }, this.renderSelectContent(triggerRenderKeys))), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
          key: 'suffix'
        }, suffix ? this.renderSuffix() : null), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
          key: 'clearBtn'
        }, showClear || isTriggerPositionSearch && inputValue ? this.renderClearBtn() : null), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
          key: 'arrow'
        }, this.renderArrow())];
      }
      const tabIndex = disabled ? null : 0;
      /**
       * Reasons for disabling the a11y eslint rule:
       * The following attributes(aria-controls,aria-expanded) will be automatically added by Tooltip, no need to declare here
       */
      return /*#__PURE__*/_react.default.createElement("div", Object.assign({
        // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
        role: 'combobox',
        "aria-disabled": disabled,
        "aria-haspopup": "tree",
        tabIndex: tabIndex,
        className: classNames,
        style: style,
        ref: this.triggerRef,
        onClick: this.handleClick,
        onKeyPress: this.handleSelectionEnterPress,
        onKeyDown: this.foundation.handleKeyDown,
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-label": this.props['aria-label'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required']
      }, mouseEvent, this.getDataAttr(rest)), inner);
    };
    this.renderTagItem = (key, idx) => {
      const {
        keyEntities,
        disabledKeys
      } = this.state;
      const {
        size,
        leafOnly,
        disabled,
        disableStrictly,
        renderSelectedItem: propRenderSelectedItem,
        treeNodeLabelProp,
        keyMaps
      } = this.props;
      const realLabelName = (0, _get2.default)(keyMaps, 'label', treeNodeLabelProp);
      const keyList = (0, _treeUtil.normalizeKeyList)([key], keyEntities, leafOnly, true);
      const nodes = keyList.map(i => keyEntities[key] && keyEntities[key].key === key ? keyEntities[key].data : this.getDataForKeyNotInKeyEntities(key));
      const value = (0, _treeUtil.getValueOrKey)(nodes, keyMaps);
      const tagCls = (0, _classnames.default)(`${prefixcls}-selection-tag`, {
        [`${prefixcls}-selection-tag-disabled`]: disabled
      });
      const nodeHaveData = !(0, _isEmpty2.default)(nodes) && !(0, _isEmpty2.default)(nodes[0]);
      const isDisableStrictlyNode = disableStrictly && nodeHaveData && disabledKeys.has(nodes[0].key);
      const closable = nodeHaveData && !nodes[0].disabled && !disabled && !isDisableStrictlyNode;
      const onClose = (tagChildren, e) => {
        // When value has not changed, prevent clicking tag closeBtn to close tag
        e.preventDefault();
        this.removeTag(key);
      };
      const tagProps = {
        size: size === 'small' ? 'small' : 'large',
        key: `tag-${value}-${idx}`,
        color: 'white',
        className: tagCls,
        closable,
        onClose
      };
      const item = nodes[0];
      const renderSelectedItem = (0, _isFunction2.default)(propRenderSelectedItem) ? propRenderSelectedItem : selectedItem => ({
        isRenderInTag: true,
        content: (0, _get2.default)(selectedItem, realLabelName, null)
      });
      if ((0, _isFunction2.default)(renderSelectedItem)) {
        const {
          content,
          isRenderInTag
        } = item ? renderSelectedItem(item, {
          index: idx,
          onClose
        }) : {};
        if (isRenderInTag) {
          return /*#__PURE__*/_react.default.createElement(_index.default, Object.assign({}, tagProps), content);
        } else {
          return content;
        }
      }
      return /*#__PURE__*/_react.default.createElement(_index.default, Object.assign({}, tagProps), value);
    };
    this.renderTagInput = triggerRenderKeys => {
      const {
        disabled,
        size,
        searchAutoFocus,
        placeholder,
        maxTagCount,
        showRestTagsPopover,
        restTagsPopoverProps,
        searchPosition,
        filterTreeNode,
        preventScroll
      } = this.props;
      const {
        inputValue
      } = this.state;
      // auto focus search input divide into two parts
      // 1. filterTreeNode && searchPosition === strings.SEARCH_POSITION_TRIGGER
      //    Implemented by passing autofocus to the underlying input's autofocus
      // 2. filterTreeNode && searchPosition === strings.SEARCH_POSITION_DROPDOWN
      //    Due to the off-screen rendering in the tooltip implementation mechanism, if it is implemented through the 
      //    autofocus of the input, when the option panel is opened, the page will scroll to top, so it is necessary 
      //    to call the focus method through ref in the onVisibleChange callback of the Popover to achieve focus
      const autoFocus = filterTreeNode && searchPosition === _constants.strings.SEARCH_POSITION_TRIGGER ? searchAutoFocus : undefined;
      return /*#__PURE__*/_react.default.createElement(_tagInput.default, {
        maxTagCount: maxTagCount,
        disabled: disabled,
        onInputChange: v => this.search(v),
        ref: this.tagInputRef,
        placeholder: placeholder,
        value: triggerRenderKeys,
        inputValue: inputValue,
        size: size,
        showRestTagsPopover: showRestTagsPopover,
        restTagsPopoverProps: restTagsPopoverProps,
        // eslint-disable-next-line jsx-a11y/no-autofocus
        autoFocus: autoFocus,
        renderTagItem: (itemKey, index) => this.renderTagItem(itemKey, index),
        onRemove: itemKey => this.removeTag(itemKey),
        expandRestTagsOnClick: false,
        preventScroll: preventScroll
      });
    };
    // render Tree
    this.renderInput = () => {
      const {
        searchPlaceholder,
        searchRender,
        showSearchClear,
        searchPosition,
        searchAutoFocus,
        multiple,
        disabled,
        preventScroll
      } = this.props;
      const isDropdownPositionSearch = searchPosition === _constants.strings.SEARCH_POSITION_DROPDOWN;
      const inputcls = (0, _classnames.default)({
        [`${prefixTree}-input`]: isDropdownPositionSearch,
        [`${prefixcls}-inputTrigger`]: !isDropdownPositionSearch
      });
      const {
        inputValue
      } = this.state;
      const baseInputProps = {
        value: inputValue,
        className: inputcls,
        preventScroll,
        onChange: value => this.search(value)
      };
      const inputDropdownProps = {
        showClear: showSearchClear,
        prefix: /*#__PURE__*/_react.default.createElement(_semiIcons.IconSearch, null)
      };
      const inputTriggerProps = {
        autofocus: searchAutoFocus,
        onFocus: e => this.foundation.handleInputTriggerFocus(),
        onBlur: e => this.foundation.handleInputTriggerBlur(),
        disabled
      };
      const realInputProps = isDropdownPositionSearch ? inputDropdownProps : inputTriggerProps;
      const wrapperCls = (0, _classnames.default)({
        [`${prefixTree}-search-wrapper`]: isDropdownPositionSearch,
        [`${prefixcls}-triggerSingleSearch-wrapper`]: !isDropdownPositionSearch && !multiple
      });
      const useCusSearch = typeof searchRender === 'function' || typeof searchRender === 'boolean';
      if (useCusSearch && !searchRender) {
        return null;
      }
      return /*#__PURE__*/_react.default.createElement("div", {
        className: wrapperCls
      }, /*#__PURE__*/_react.default.createElement(_localeConsumer.default, {
        componentName: "TreeSelect"
      }, locale => {
        const placeholder = isDropdownPositionSearch ? searchPlaceholder || locale.searchPlaceholder : '';
        if (useCusSearch) {
          return searchRender(Object.assign(Object.assign(Object.assign({}, realInputProps), baseInputProps), {
            placeholder
          }));
        }
        return /*#__PURE__*/_react.default.createElement(_index2.default, Object.assign({
          "aria-label": 'Filter TreeSelect item',
          ref: this.inputRef,
          placeholder: placeholder
        }, baseInputProps, realInputProps));
      }));
    };
    this.renderEmpty = () => {
      const {
        emptyContent
      } = this.props;
      if (emptyContent === null) {
        return null;
      }
      if (emptyContent) {
        return /*#__PURE__*/_react.default.createElement(_treeNode.default, {
          empty: true,
          emptyContent: this.props.emptyContent
        });
      } else {
        return /*#__PURE__*/_react.default.createElement(_localeConsumer.default, {
          componentName: "Tree"
        }, locale => /*#__PURE__*/_react.default.createElement(_treeNode.default, {
          empty: true,
          emptyContent: locale.emptyText
        }));
      }
    };
    this.onNodeLoad = data => new Promise(resolve => this.foundation.setLoadKeys(data, resolve));
    this.onNodeSelect = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };
    this.onNodeCheck = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };
    this.onNodeExpand = (e, treeNode) => {
      this.foundation.handleNodeExpand(e, treeNode);
    };
    this.getTreeNodeRequiredProps = () => {
      const {
        expandedKeys,
        selectedKeys,
        checkedKeys,
        halfCheckedKeys,
        keyEntities,
        filteredKeys
      } = this.state;
      return {
        expandedKeys: expandedKeys || new Set(),
        selectedKeys: selectedKeys || [],
        checkedKeys: checkedKeys || new Set(),
        halfCheckedKeys: halfCheckedKeys || new Set(),
        filteredKeys: filteredKeys || new Set(),
        keyEntities
      };
    };
    this.getTreeNodeKey = treeNode => {
      const {
        data
      } = treeNode;
      const {
        key
      } = data;
      return key;
    };
    /* Event handler function after popover visible change */
    this.handlePopoverVisibleChange = isVisible => {
      this.foundation.handlePopoverVisibleChange(isVisible);
    };
    this.afterClose = () => {
      this.foundation.handleAfterClose();
    };
    this.renderTreeNode = (treeNode, ind, style) => {
      const {
        data,
        key
      } = treeNode;
      const treeNodeProps = this.foundation.getTreeNodeProps(key);
      const {
        showLine
      } = this.props;
      if (!treeNodeProps) {
        return null;
      }
      const props = (0, _pick2.default)(treeNode, ['key', 'label', 'disabled', 'isLeaf', 'icon', 'isEnd']);
      const {
        keyMaps
      } = this.props;
      const children = data[(0, _get2.default)(keyMaps, 'children', 'children')];
      !(0, _isUndefined2.default)(children) && (props.children = children);
      return /*#__PURE__*/_react.default.createElement(_treeNode.default, Object.assign({}, treeNodeProps, data, props, {
        data: data,
        style: style,
        showLine: showLine
      }));
    };
    this.itemKey = (index, data) => {
      const {
        visibleOptions
      } = data;
      // Find the item at the specified index.
      const item = visibleOptions[index];
      // Return a value that uniquely identifies this item.
      return item.key;
    };
    this.renderNodeList = () => {
      const {
        flattenNodes,
        cachedFlattenNodes,
        motionKeys,
        motionType,
        filteredKeys
      } = this.state;
      const {
        direction
      } = this.context;
      const {
        virtualize,
        motionExpand
      } = this.props;
      const isExpandControlled = 'expandedKeys' in this.props;
      if (!virtualize || (0, _isEmpty2.default)(virtualize)) {
        return /*#__PURE__*/_react.default.createElement(_nodeList.default, {
          flattenNodes: flattenNodes,
          flattenList: cachedFlattenNodes,
          motionKeys: motionExpand ? motionKeys : new Set([]),
          motionType: motionType,
          // When motionKeys is empty, but filteredKeys is not empty (that is, the search hits), this situation should be distinguished from ordinary motionKeys
          searchTargetIsDeep: isExpandControlled && motionExpand && (0, _isEmpty2.default)(motionKeys) && !(0, _isEmpty2.default)(filteredKeys),
          onMotionEnd: this.onMotionEnd,
          renderTreeNode: this.renderTreeNode
        });
      }
      const data = {
        visibleOptions: flattenNodes,
        renderOption: this.renderTreeNode
      };
      return /*#__PURE__*/_react.default.createElement(_autoSizer.default, {
        defaultHeight: virtualize.height,
        defaultWidth: virtualize.width
      }, _ref => {
        let {
          height,
          width
        } = _ref;
        return /*#__PURE__*/_react.default.createElement(_reactWindow.FixedSizeList, {
          itemCount: flattenNodes.length,
          itemSize: virtualize.itemSize,
          height: height,
          width: width,
          // @ts-ignore avoid strict check of itemKey
          itemKey: this.itemKey,
          itemData: data,
          className: `${prefixTree}-virtual-list`,
          style: {
            direction
          }
        }, _virtualRow.default);
      });
    };
    this.renderTree = () => {
      const {
        keyEntities,
        motionKeys,
        motionType,
        inputValue,
        filteredKeys,
        flattenNodes,
        checkedKeys,
        realCheckedKeys
      } = this.state;
      const {
        loadData,
        filterTreeNode,
        disabled,
        multiple,
        showFilteredOnly,
        motionExpand,
        outerBottomSlot,
        outerTopSlot,
        expandAction,
        labelEllipsis,
        virtualize,
        optionListStyle,
        searchPosition,
        renderLabel,
        renderFullLabel,
        checkRelation,
        emptyContent
      } = this.props;
      const wrapperCls = (0, _classnames.default)(`${prefixTree}-wrapper`);
      const searchNoRes = Boolean(inputValue) && !filteredKeys.size;
      const noData = (0, _isEmpty2.default)(flattenNodes) || showFilteredOnly && searchNoRes;
      const isDropdownPositionSearch = searchPosition === _constants.strings.SEARCH_POSITION_DROPDOWN;
      const listCls = (0, _classnames.default)(`${prefixTree}-option-list ${prefixTree}-option-list-block`, {
        [`${prefixTree}-option-list-hidden`]: emptyContent === null && noData
      });
      return /*#__PURE__*/_react.default.createElement(_treeContext.default.Provider, {
        value: {
          loadData,
          treeDisabled: disabled,
          motion: motionExpand,
          motionKeys,
          motionType,
          expandAction,
          filterTreeNode,
          keyEntities,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          // tree node will call this function when treeNode is right clicked
          onNodeRightClick: _noop2.default,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          renderTreeNode: this.renderTreeNode,
          multiple,
          showFilteredOnly,
          isSearching: Boolean(inputValue),
          renderLabel,
          renderFullLabel,
          labelEllipsis: typeof labelEllipsis === 'undefined' ? virtualize : labelEllipsis
        }
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: wrapperCls
      }, outerTopSlot, !outerTopSlot && filterTreeNode && isDropdownPositionSearch && this.renderInput(), /*#__PURE__*/_react.default.createElement("div", {
        className: listCls,
        role: "tree",
        "aria-multiselectable": multiple ? true : false,
        style: optionListStyle
      }, noData ? this.renderEmpty() : multiple ? (/*#__PURE__*/_react.default.createElement(_checkboxGroup.default, {
        value: Array.from(checkRelation === 'related' ? checkedKeys : realCheckedKeys)
      }, this.renderNodeList())) : this.renderNodeList()), outerBottomSlot));
    };
    this.state = {
      inputTriggerFocus: false,
      isOpen: false,
      isFocus: false,
      // isInput: false,
      rePosKey: key,
      dropdownMinWidth: null,
      inputValue: '',
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      cachedFlattenNodes: undefined,
      selectedKeys: [],
      checkedKeys: new Set(),
      halfCheckedKeys: new Set(),
      realCheckedKeys: new Set([]),
      disabledKeys: new Set(),
      motionKeys: new Set([]),
      motionType: 'hide',
      expandedKeys: new Set(props.expandedKeys),
      filteredKeys: new Set(),
      filteredExpandedKeys: new Set(),
      filteredShownKeys: new Set(),
      prevProps: null,
      isHovering: false,
      cachedKeyValuePairs: {},
      loadedKeys: new Set(),
      loadingKeys: new Set()
    };
    this.inputRef = /*#__PURE__*/_react.default.createRef();
    this.tagInputRef = /*#__PURE__*/_react.default.createRef();
    this.triggerRef = /*#__PURE__*/_react.default.createRef();
    this.optionsRef = /*#__PURE__*/_react.default.createRef();
    this.clickOutsideHandler = null;
    this.foundation = new _foundation.default(this.adapter);
    this.treeSelectID = Math.random().toString(36).slice(2);
    this.onMotionEnd = () => {
      this.adapter.rePositionDropdown();
    };
  }
  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps,
      rePosKey
    } = prevState;
    const {
      keyMaps
    } = props;
    const needUpdate = name => !prevProps && name in props || prevProps && !(0, _isEqual2.default)(prevProps[name], props[name]);
    let treeData;
    const withObject = props.onChangeWithObject;
    let keyEntities = prevState.keyEntities || {};
    let valueEntities = prevState.cachedKeyValuePairs || {};
    const newState = {
      prevProps: props
    };
    const needUpdateTreeData = needUpdate('treeData');
    const needUpdateExpandedKeys = needUpdate('expandedKeys');
    const isExpandControlled = 'expandedKeys' in props;
    const isSearching = Boolean(props.filterTreeNode && prevState.inputValue && prevState.inputValue.length);
    // TreeNode
    if (needUpdateTreeData) {
      treeData = props.treeData;
      newState.treeData = treeData;
      const entitiesMap = (0, _treeUtil.convertDataToEntities)(treeData, keyMaps);
      newState.keyEntities = Object.assign({}, entitiesMap.keyEntities);
      keyEntities = newState.keyEntities;
      newState.cachedKeyValuePairs = Object.assign({}, entitiesMap.valueEntities);
      valueEntities = newState.cachedKeyValuePairs;
    }
    // if treeData keys changes, we won't show animation
    if (treeData && props.motion && !(0, _isEqual2.default)(Object.keys(newState.keyEntities), Object.keys(prevState.keyEntities))) {
      if (prevProps && props.motion) {
        newState.motionKeys = new Set([]);
        newState.motionType = null;
      }
    }
    const expandAllWhenDataChange = needUpdateTreeData && props.expandAll;
    if (!isSearching) {
      // expandedKeys
      if (needUpdateExpandedKeys || prevProps && needUpdate('autoExpandParent')) {
        newState.expandedKeys = (0, _treeUtil.calcExpandedKeys)(props.expandedKeys, keyEntities, props.autoExpandParent || !prevProps);
        // only show animation when treeData does not change
        if (prevProps && props.motion && !treeData) {
          const {
            motionKeys,
            motionType
          } = (0, _treeUtil.calcMotionKeys)(prevState.expandedKeys, newState.expandedKeys, keyEntities);
          newState.motionKeys = new Set(motionKeys);
          newState.motionType = motionType;
          if (motionType === 'hide') {
            // cache flatten nodes: expandedKeys changed may not be triggered by interaction
            newState.cachedFlattenNodes = (0, _treeUtil2.cloneDeep)(prevState.flattenNodes);
          }
        }
      } else if (!prevProps && (props.defaultExpandAll || props.expandAll) || expandAllWhenDataChange) {
        newState.expandedKeys = new Set(Object.keys(keyEntities));
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = (0, _treeUtil.calcExpandedKeys)(props.defaultExpandedKeys, keyEntities);
      } else if (!prevProps && props.defaultValue) {
        newState.expandedKeys = (0, _treeUtil.calcExpandedKeysForValues)((0, _treeUtil.normalizeValue)(props.defaultValue, withObject, keyMaps), keyEntities, props.multiple, valueEntities);
      } else if (!prevProps && props.value) {
        newState.expandedKeys = (0, _treeUtil.calcExpandedKeysForValues)((0, _treeUtil.normalizeValue)(props.value, withObject, keyMaps), keyEntities, props.multiple, valueEntities);
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      if (treeData || newState.expandedKeys) {
        const flattenNodes = (0, _treeUtil.flattenTreeData)(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, keyMaps);
        newState.flattenNodes = flattenNodes;
      }
    } else {
      let filteredState;
      // treeData changed while searching
      if (treeData) {
        // Get filter data
        filteredState = (0, _treeUtil.filterTreeData)({
          treeData,
          inputValue: prevState.inputValue,
          filterTreeNode: props.filterTreeNode,
          filterProps: props.treeNodeFilterProp,
          showFilteredOnly: props.showFilteredOnly,
          keyEntities: newState.keyEntities,
          prevExpandedKeys: [...prevState.filteredExpandedKeys],
          keyMaps: keyMaps
        });
        newState.flattenNodes = filteredState.flattenNodes;
        newState.motionKeys = new Set([]);
        newState.filteredKeys = filteredState.filteredKeys;
        newState.filteredShownKeys = filteredState.filteredShownKeys;
        newState.filteredExpandedKeys = filteredState.filteredExpandedKeys;
      }
      // expandedKeys changed while searching
      if (props.expandedKeys) {
        newState.filteredExpandedKeys = (0, _treeUtil.calcExpandedKeys)(props.expandedKeys, keyEntities, props.autoExpandParent || !prevProps);
        if (prevProps && props.motion) {
          const prevKeys = prevState ? prevState.filteredExpandedKeys : new Set([]);
          // only show animation when treeData does not change
          if (!treeData) {
            const motionResult = (0, _treeUtil.calcMotionKeys)(prevKeys, newState.filteredExpandedKeys, keyEntities);
            let {
              motionKeys
            } = motionResult;
            const {
              motionType
            } = motionResult;
            if (props.showFilteredOnly) {
              motionKeys = motionKeys.filter(key => prevState.filteredShownKeys.has(key));
            }
            if (motionType === 'hide') {
              // cache flatten nodes: expandedKeys changed may not be triggered by interaction
              newState.cachedFlattenNodes = (0, _treeUtil2.cloneDeep)(prevState.flattenNodes);
            }
            newState.motionKeys = new Set(motionKeys);
            newState.motionType = motionType;
          }
        }
        newState.flattenNodes = (0, _treeUtil.flattenTreeData)(treeData || prevState.treeData, newState.filteredExpandedKeys || prevState.filteredExpandedKeys, keyMaps, props.showFilteredOnly && prevState.filteredShownKeys);
      }
    }
    // selectedKeys: single mode controlled
    const isMultiple = props.multiple;
    if (!isMultiple) {
      if (needUpdate('value')) {
        newState.selectedKeys = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.value, withObject, keyMaps), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        newState.selectedKeys = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.defaultValue, withObject, keyMaps), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          newState.selectedKeys = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.value, withObject, keyMaps) || '', valueEntities, isMultiple);
        } else {
          newState.selectedKeys = (0, _treeUtil.updateKeys)(prevState.selectedKeys, keyEntities);
        }
      }
    } else {
      // checkedKeys: multiple mode controlled || data changed
      let checkedKeyValues;
      if (needUpdate('value')) {
        checkedKeyValues = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.value, withObject, keyMaps), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        checkedKeyValues = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.defaultValue, withObject, keyMaps), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          checkedKeyValues = (0, _treeUtil.findKeysForValues)((0, _treeUtil.normalizeValue)(props.value, withObject, keyMaps) || [], valueEntities, isMultiple);
        } else {
          checkedKeyValues = (0, _treeUtil.updateKeys)(props.checkRelation === 'related' ? prevState.checkedKeys : prevState.realCheckedKeys, keyEntities);
        }
      }
      if (checkedKeyValues) {
        if (props.checkRelation === 'unRelated') {
          newState.realCheckedKeys = new Set(checkedKeyValues);
        } else if (props.checkRelation === 'related') {
          const {
            checkedKeys,
            halfCheckedKeys
          } = (0, _treeUtil.calcCheckedKeys)(checkedKeyValues, keyEntities);
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
    }
    // loadedKeys
    if (needUpdate('loadedKeys')) {
      newState.loadedKeys = new Set(props.loadedKeys);
    }
    // ================== rePosKey ==================
    if (needUpdateTreeData || needUpdate('value')) {
      newState.rePosKey = rePosKey + 1;
    }
    // ================ disableStrictly =================
    if (treeData && props.disableStrictly && props.checkRelation === 'related') {
      newState.disabledKeys = (0, _treeUtil.calcDisabledKeys)(keyEntities, keyMaps);
    }
    return newState;
  }
  get adapter() {
    var _this = this;
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      }
    };
    const treeSelectAdapter = {
      registerClickOutsideHandler: cb => {
        this.adapter.unregisterClickOutsideHandler();
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current;
          const optionsDom = _reactDom.default.findDOMNode(optionInstance);
          const target = e.target;
          const path = e.composedPath && e.composedPath() || [target];
          if (optionsDom && (!optionsDom.contains(target) || !optionsDom.contains(target.parentNode)) && triggerDom && !triggerDom.contains(target) && !(path.includes(triggerDom) || path.includes(optionsDom))) {
            cb(e);
          }
        };
        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        if (!this.clickOutsideHandler) {
          return;
        }
        document.removeEventListener('mousedown', this.clickOutsideHandler, false);
        this.clickOutsideHandler = null;
      },
      rePositionDropdown: () => {
        let {
          rePosKey
        } = this.state;
        rePosKey = rePosKey + 1;
        this.setState({
          rePosKey
        });
      }
    };
    const treeAdapter = {
      updateState: states => {
        this.setState(Object.assign({}, states));
      },
      notifySelect: (selectKey, bool, node) => {
        this.props.onSelect && this.props.onSelect(selectKey, bool, node);
      },
      notifySearch: (input, filteredExpandedKeys, filteredNodes) => {
        this.props.onSearch && this.props.onSearch(input, filteredExpandedKeys, filteredNodes);
      },
      cacheFlattenNodes: bool => {
        this.setState({
          cachedFlattenNodes: bool ? (0, _treeUtil2.cloneDeep)(this.state.flattenNodes) : undefined
        });
      },
      notifyLoad: (newLoadedKeys, data) => {
        const {
          onLoad
        } = this.props;
        (0, _isFunction2.default)(onLoad) && onLoad(newLoadedKeys, data);
      },
      notifyClear: e => {
        this.props.onClear && this.props.onClear(e);
      }
    };
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), filterAdapter), treeSelectAdapter), treeAdapter), {
      updateLoadKeys: (data, resolve) => {
        this.setState(_ref2 => {
          let {
            loadedKeys,
            loadingKeys
          } = _ref2;
          return this.foundation.handleNodeLoad(loadedKeys, loadingKeys, data, resolve);
        });
      },
      updateState: states => {
        this.setState(Object.assign({}, states));
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        }, () => {
          this.props.onVisibleChange(true);
        });
      },
      closeMenu: cb => {
        this.setState({
          isOpen: false
        }, () => {
          cb && cb();
          this.props.onVisibleChange(false);
        });
      },
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      notifyChange: (value, node, e) => {
        this.props.onChange && this.props.onChange(value, node, e);
      },
      notifyChangeWithObject: (node, e) => {
        this.props.onChange && this.props.onChange(node, e);
      },
      notifyExpand: (expandedKeys, _ref3) => {
        let {
          expanded: bool,
          node
        } = _ref3;
        this.props.onExpand && this.props.onExpand([...expandedKeys], {
          expanded: bool,
          node
        });
        if (bool && this.props.loadData) {
          this.onNodeLoad(node);
        }
      },
      notifyFocus: function () {
        _this.props.onFocus && _this.props.onFocus(...arguments);
      },
      notifyBlur: function () {
        _this.props.onBlur && _this.props.onBlur(...arguments);
      },
      toggleHovering: bool => {
        this.setState({
          isHovering: bool
        });
      },
      updateInputFocus: bool => {
        if (bool) {
          if (this.inputRef && this.inputRef.current) {
            const {
              preventScroll
            } = this.props;
            this.inputRef.current.focus({
              preventScroll
            });
          }
          if (this.tagInputRef && this.tagInputRef.current) {
            this.tagInputRef.current.focus();
          }
        } else {
          if (this.inputRef && this.inputRef.current) {
            this.inputRef.current.blur();
          }
          if (this.tagInputRef && this.tagInputRef.current) {
            this.tagInputRef.current.blur();
          }
        }
      },
      updateIsFocus: bool => {
        this.setState({
          isFocus: bool
        });
      }
    });
  }
  componentDidMount() {
    this.foundation.init();
  }
  componentWillUnmount() {
    this.foundation.destroy();
  }
  render() {
    const content = this.renderContent();
    const {
      motion,
      zIndex,
      mouseLeaveDelay,
      mouseEnterDelay,
      autoAdjustOverflow,
      stopPropagation,
      getPopupContainer,
      dropdownMargin,
      position
    } = this.props;
    const {
      isOpen,
      rePosKey
    } = this.state;
    const selection = this.renderSelection();
    const pos = position ? position : 'bottomLeft';
    return /*#__PURE__*/_react.default.createElement(_index3.default, {
      stopPropagation: stopPropagation,
      getPopupContainer: getPopupContainer,
      zIndex: zIndex,
      motion: motion,
      margin: dropdownMargin,
      ref: this.optionsRef,
      content: content,
      visible: isOpen,
      trigger: "custom",
      rePosKey: rePosKey,
      position: pos,
      autoAdjustOverflow: autoAdjustOverflow,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      onVisibleChange: this.handlePopoverVisibleChange,
      afterClose: this.afterClose
    }, selection);
  }
}
TreeSelect.contextType = _context.default;
TreeSelect.propTypes = {
  'aria-describedby': _propTypes.default.string,
  'aria-errormessage': _propTypes.default.string,
  'aria-invalid': _propTypes.default.bool,
  'aria-labelledby': _propTypes.default.string,
  'aria-required': _propTypes.default.bool,
  borderless: _propTypes.default.bool,
  loadedKeys: _propTypes.default.arrayOf(_propTypes.default.string),
  loadData: _propTypes.default.func,
  onLoad: _propTypes.default.func,
  arrowIcon: _propTypes.default.node,
  clearIcon: _propTypes.default.node,
  defaultOpen: _propTypes.default.bool,
  defaultValue: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array, _propTypes.default.object]),
  defaultExpandAll: _propTypes.default.bool,
  defaultExpandedKeys: _propTypes.default.array,
  expandAll: _propTypes.default.bool,
  disabled: _propTypes.default.bool,
  disableStrictly: _propTypes.default.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filterTreeNode: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),
  multiple: _propTypes.default.bool,
  searchPlaceholder: _propTypes.default.string,
  searchAutoFocus: _propTypes.default.bool,
  virtualize: _propTypes.default.object,
  treeNodeFilterProp: _propTypes.default.string,
  onChange: _propTypes.default.func,
  onClear: _propTypes.default.func,
  onSearch: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  onExpand: _propTypes.default.func,
  onChangeWithObject: _propTypes.default.bool,
  onBlur: _propTypes.default.func,
  onFocus: _propTypes.default.func,
  value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number, _propTypes.default.array, _propTypes.default.object]),
  expandedKeys: _propTypes.default.array,
  autoExpandParent: _propTypes.default.bool,
  showClear: _propTypes.default.bool,
  showSearchClear: _propTypes.default.bool,
  autoAdjustOverflow: _propTypes.default.bool,
  showFilteredOnly: _propTypes.default.bool,
  showLine: _propTypes.default.bool,
  motionExpand: _propTypes.default.bool,
  emptyContent: _propTypes.default.node,
  keyMaps: _propTypes.default.object,
  leafOnly: _propTypes.default.bool,
  treeData: _propTypes.default.arrayOf(_propTypes.default.shape({
    key: _propTypes.default.string,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
    label: _propTypes.default.any
  })),
  dropdownClassName: _propTypes.default.string,
  dropdownStyle: _propTypes.default.object,
  dropdownMargin: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.object]),
  motion: _propTypes.default.bool,
  placeholder: _propTypes.default.string,
  maxTagCount: _propTypes.default.number,
  size: _propTypes.default.oneOf(_constants.strings.SIZE_SET),
  className: _propTypes.default.string,
  style: _propTypes.default.object,
  treeNodeLabelProp: _propTypes.default.string,
  suffix: _propTypes.default.node,
  prefix: _propTypes.default.node,
  insetLabel: _propTypes.default.node,
  insetLabelId: _propTypes.default.string,
  zIndex: _propTypes.default.number,
  getPopupContainer: _propTypes.default.func,
  dropdownMatchSelectWidth: _propTypes.default.bool,
  validateStatus: _propTypes.default.oneOf(_constants.strings.STATUS),
  mouseEnterDelay: _propTypes.default.number,
  mouseLeaveDelay: _propTypes.default.number,
  triggerRender: _propTypes.default.func,
  stopPropagation: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  outerBottomSlot: _propTypes.default.node,
  outerTopSlot: _propTypes.default.node,
  onVisibleChange: _propTypes.default.func,
  expandAction: _propTypes.default.oneOf(['click', 'doubleClick', false]),
  searchPosition: _propTypes.default.oneOf([_constants.strings.SEARCH_POSITION_DROPDOWN, _constants.strings.SEARCH_POSITION_TRIGGER]),
  clickToHide: _propTypes.default.bool,
  renderLabel: _propTypes.default.func,
  renderFullLabel: _propTypes.default.func,
  labelEllipsis: _propTypes.default.bool,
  optionListStyle: _propTypes.default.object,
  searchRender: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),
  renderSelectedItem: _propTypes.default.func,
  checkRelation: _propTypes.default.string,
  'aria-label': _propTypes.default.string,
  showRestTagsPopover: _propTypes.default.bool,
  restTagsPopoverProps: _propTypes.default.object,
  preventScroll: _propTypes.default.bool,
  clickTriggerToHide: _propTypes.default.bool,
  autoMergeValue: _propTypes.default.bool
};
TreeSelect.defaultProps = {
  borderless: false,
  searchPosition: _constants.strings.SEARCH_POSITION_DROPDOWN,
  arrowIcon: /*#__PURE__*/_react.default.createElement(_semiIcons.IconChevronDown, null),
  autoExpandParent: false,
  autoAdjustOverflow: true,
  stopPropagation: true,
  motion: true,
  motionExpand: true,
  expandAll: false,
  zIndex: _constants2.numbers.DEFAULT_Z_INDEX,
  disableStrictly: false,
  multiple: false,
  filterTreeNode: false,
  size: 'default',
  treeNodeFilterProp: 'label',
  onChangeWithObject: false,
  treeNodeLabelProp: 'label',
  dropdownMatchSelectWidth: true,
  defaultOpen: false,
  showSearchClear: true,
  showClear: false,
  onVisibleChange: _noop2.default,
  expandAction: false,
  clickToHide: true,
  searchAutoFocus: false,
  checkRelation: 'related',
  'aria-label': 'TreeSelect',
  showRestTagsPopover: false,
  restTagsPopoverProps: {},
  clickTriggerToHide: true,
  autoMergeValue: true
};
var _default = exports.default = TreeSelect;