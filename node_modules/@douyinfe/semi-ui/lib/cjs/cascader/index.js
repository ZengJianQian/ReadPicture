"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isObject2 = _interopRequireDefault(require("lodash/isObject"));
var _noop2 = _interopRequireDefault(require("lodash/noop"));
var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));
var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _isString2 = _interopRequireDefault(require("lodash/isString"));
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _isSet2 = _interopRequireDefault(require("lodash/isSet"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _classnames = _interopRequireDefault(require("classnames"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/cascader/foundation"));
var _constants = require("@douyinfe/semi-foundation/lib/cjs/cascader/constants");
var _constants2 = require("@douyinfe/semi-foundation/lib/cjs/popover/constants");
require("@douyinfe/semi-foundation/lib/cjs/cascader/cascader.css");
var _semiIcons = require("@douyinfe/semi-icons");
var _util = require("@douyinfe/semi-foundation/lib/cjs/cascader/util");
var _treeUtil = require("@douyinfe/semi-foundation/lib/cjs/tree/treeUtil");
var _context = _interopRequireDefault(require("../configProvider/context"));
var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));
var _index = _interopRequireDefault(require("../input/index"));
var _index2 = _interopRequireDefault(require("../popover/index"));
var _item = _interopRequireDefault(require("./item"));
var _trigger = _interopRequireDefault(require("../trigger"));
var _tag = _interopRequireDefault(require("../tag"));
var _tagInput = _interopRequireDefault(require("../tagInput"));
var _utils = require("../_utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const prefixcls = _constants.cssClasses.PREFIX;
const resetkey = 0;
class Cascader extends _baseComponent.default {
  constructor(props) {
    super(props);
    // ref method
    this.search = value => {
      this.handleInputChange(value);
    };
    this.handleInputChange = value => {
      this.foundation.handleInputChange(value);
    };
    this.handleTagRemoveInTrigger = pos => {
      this.foundation.handleTagRemoveInTrigger(pos);
    };
    this.handleTagClose = (tagChildren, e, tagKey) => {
      // When value has not changed, prevent clicking tag closeBtn to close tag
      e.preventDefault();
      this.foundation.handleTagRemoveByKey(tagKey);
    };
    this.renderTagItem = (nodeKey, idx) => {
      const {
        keyEntities,
        disabledKeys
      } = this.state;
      const {
        size,
        disabled,
        displayProp,
        displayRender,
        disableStrictly
      } = this.props;
      if (keyEntities[nodeKey]) {
        const isDisabled = disabled || keyEntities[nodeKey].data.disabled || disableStrictly && disabledKeys.has(nodeKey);
        const tagCls = (0, _classnames.default)(`${prefixcls}-selection-tag`, {
          [`${prefixcls}-selection-tag-disabled`]: isDisabled
        });
        // custom render tags
        if ((0, _isFunction2.default)(displayRender)) {
          return displayRender(keyEntities[nodeKey], idx);
          // default render tags
        } else {
          return /*#__PURE__*/_react.default.createElement(_tag.default, {
            size: size === 'default' ? 'large' : size,
            key: `tag-${nodeKey}-${idx}`,
            color: "white",
            tagKey: nodeKey,
            className: tagCls,
            closable: true,
            onClose: this.handleTagClose
          }, keyEntities[nodeKey].data[displayProp]);
        }
      }
      return null;
    };
    this.onRemoveInTagInput = v => {
      this.foundation.handleTagRemoveByKey(v);
    };
    this.handleItemClick = (e, item) => {
      this.foundation.handleItemClick(e, item);
    };
    this.handleItemHover = (e, item) => {
      this.foundation.handleItemHover(e, item);
    };
    this.onItemCheckboxClick = item => {
      this.foundation.onItemCheckboxClick(item);
    };
    this.handleListScroll = (e, ind) => {
      this.foundation.handleListScroll(e, ind);
    };
    this.renderContent = () => {
      const {
        inputValue,
        isSearching,
        activeKeys,
        selectedKeys,
        checkedKeys,
        halfCheckedKeys,
        loadedKeys,
        loadingKeys
      } = this.state;
      const {
        filterTreeNode,
        dropdownClassName,
        dropdownStyle,
        loadData,
        emptyContent,
        separator,
        topSlot,
        bottomSlot,
        showNext,
        multiple,
        filterRender,
        virtualizeInSearch,
        expandIcon
      } = this.props;
      const searchable = Boolean(filterTreeNode) && isSearching;
      const popoverCls = (0, _classnames.default)(dropdownClassName, `${prefixcls}-popover`);
      const renderData = this.foundation.getRenderData();
      const content = /*#__PURE__*/_react.default.createElement("div", {
        className: popoverCls,
        role: "listbox",
        style: dropdownStyle,
        onKeyDown: this.foundation.handleKeyDown
      }, topSlot, /*#__PURE__*/_react.default.createElement(_item.default, {
        activeKeys: activeKeys,
        selectedKeys: selectedKeys,
        separator: separator,
        loadedKeys: loadedKeys,
        loadingKeys: loadingKeys,
        onItemClick: this.handleItemClick,
        onItemHover: this.handleItemHover,
        showNext: showNext,
        onItemCheckboxClick: this.onItemCheckboxClick,
        onListScroll: this.handleListScroll,
        searchable: searchable,
        keyword: inputValue,
        emptyContent: emptyContent,
        loadData: loadData,
        data: renderData,
        multiple: multiple,
        checkedKeys: checkedKeys,
        halfCheckedKeys: halfCheckedKeys,
        filterRender: filterRender,
        virtualize: virtualizeInSearch,
        expandIcon: expandIcon
      }), bottomSlot);
      return content;
    };
    this.renderPlusN = hiddenTag => {
      const {
        disabled,
        showRestTagsPopover,
        restTagsPopoverProps
      } = this.props;
      const plusNCls = (0, _classnames.default)(`${prefixcls}-selection-n`, {
        [`${prefixcls}-selection-n-disabled`]: disabled
      });
      const renderPlusNChildren = /*#__PURE__*/_react.default.createElement("span", {
        className: plusNCls
      }, "+", hiddenTag.length);
      return showRestTagsPopover ? (/*#__PURE__*/_react.default.createElement(_index2.default, Object.assign({
        content: hiddenTag,
        showArrow: true,
        trigger: "hover",
        position: "top",
        autoAdjustOverflow: true
      }, restTagsPopoverProps), renderPlusNChildren)) : renderPlusNChildren;
    };
    this.renderMultipleTags = () => {
      const {
        autoMergeValue,
        maxTagCount
      } = this.props;
      const {
        checkedKeys,
        resolvedCheckedKeys
      } = this.state;
      const realKeys = this.mergeType === _constants.strings.NONE_MERGE_TYPE ? checkedKeys : resolvedCheckedKeys;
      const displayTag = [];
      const hiddenTag = [];
      [...realKeys].forEach((checkedKey, idx) => {
        const notExceedMaxTagCount = !(0, _isNumber2.default)(maxTagCount) || maxTagCount >= idx + 1;
        const item = this.renderTagItem(checkedKey, idx);
        if (notExceedMaxTagCount) {
          displayTag.push(item);
        } else {
          hiddenTag.push(item);
        }
      });
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, displayTag, !(0, _isEmpty2.default)(hiddenTag) && this.renderPlusN(hiddenTag));
    };
    this.renderDisplayText = () => {
      const {
        displayProp,
        separator,
        displayRender
      } = this.props;
      const {
        selectedKeys
      } = this.state;
      let displayText = '';
      if (selectedKeys.size) {
        const displayPath = this.foundation.getItemPropPath([...selectedKeys][0], displayProp);
        if (displayRender && typeof displayRender === 'function') {
          displayText = displayRender(displayPath);
        } else {
          displayText = displayPath.map((path, index) => (/*#__PURE__*/_react.default.createElement(_react.Fragment, {
            key: `${path}-${index}`
          }, index < displayPath.length - 1 ? (/*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, path, separator)) : path)));
        }
      }
      return displayText;
    };
    this.renderSelectContent = () => {
      const {
        placeholder,
        filterTreeNode,
        multiple,
        searchPosition
      } = this.props;
      const {
        checkedKeys
      } = this.state;
      const searchable = Boolean(filterTreeNode) && searchPosition === _constants.strings.SEARCH_POSITION_TRIGGER;
      if (!searchable) {
        if (multiple) {
          if (checkedKeys.size === 0) {
            return /*#__PURE__*/_react.default.createElement("span", {
              className: `${prefixcls}-selection-placeholder`
            }, placeholder);
          }
          return this.renderMultipleTags();
        } else {
          const displayText = this.renderDisplayText();
          const spanCls = (0, _classnames.default)({
            [`${prefixcls}-selection-placeholder`]: !displayText
          });
          return /*#__PURE__*/_react.default.createElement("span", {
            className: spanCls
          }, displayText ? displayText : placeholder);
        }
      }
      const input = multiple ? this.renderTagInput() : this.renderInput();
      return input;
    };
    this.renderSuffix = () => {
      const {
        suffix
      } = this.props;
      const suffixWrapperCls = (0, _classnames.default)({
        [`${prefixcls}-suffix`]: true,
        [`${prefixcls}-suffix-text`]: suffix && (0, _isString2.default)(suffix),
        [`${prefixcls}-suffix-icon`]: (0, _utils.isSemiIcon)(suffix)
      });
      return /*#__PURE__*/_react.default.createElement("div", {
        className: suffixWrapperCls,
        "x-semi-prop": "suffix"
      }, suffix);
    };
    this.renderPrefix = () => {
      const {
        prefix,
        insetLabel,
        insetLabelId
      } = this.props;
      const labelNode = prefix || insetLabel;
      const prefixWrapperCls = (0, _classnames.default)({
        [`${prefixcls}-prefix`]: true,
        // to be doublechecked
        [`${prefixcls}-inset-label`]: insetLabel,
        [`${prefixcls}-prefix-text`]: labelNode && (0, _isString2.default)(labelNode),
        [`${prefixcls}-prefix-icon`]: (0, _utils.isSemiIcon)(labelNode)
      });
      return /*#__PURE__*/_react.default.createElement("div", {
        className: prefixWrapperCls,
        id: insetLabelId,
        "x-semi-prop": "prefix,insetLabel"
      }, labelNode);
    };
    this.renderCustomTrigger = () => {
      var _a;
      const {
        disabled,
        triggerRender,
        multiple
      } = this.props;
      const {
        selectedKeys,
        inputValue,
        inputPlaceHolder,
        resolvedCheckedKeys,
        checkedKeys,
        keyEntities
      } = this.state;
      let realValue;
      if (multiple) {
        if (this.mergeType === _constants.strings.NONE_MERGE_TYPE) {
          realValue = new Set();
          checkedKeys.forEach(key => {
            var _a;
            realValue.add((_a = keyEntities[key]) === null || _a === void 0 ? void 0 : _a.pos);
          });
        } else {
          realValue = new Set();
          resolvedCheckedKeys.forEach(key => {
            var _a;
            realValue.add((_a = keyEntities[key]) === null || _a === void 0 ? void 0 : _a.pos);
          });
        }
      } else {
        realValue = (_a = keyEntities[[...selectedKeys][0]]) === null || _a === void 0 ? void 0 : _a.pos;
      }
      return /*#__PURE__*/_react.default.createElement(_trigger.default, {
        value: realValue,
        inputValue: inputValue,
        onChange: this.handleInputChange,
        onClear: this.handleClear,
        placeholder: inputPlaceHolder,
        disabled: disabled,
        triggerRender: triggerRender,
        componentName: 'Cascader',
        componentProps: Object.assign({}, this.props),
        onSearch: this.handleInputChange,
        onRemove: this.handleTagRemoveInTrigger
      });
    };
    this.handleMouseOver = () => {
      this.foundation.toggleHoverState(true);
    };
    this.handleMouseLeave = () => {
      this.foundation.toggleHoverState(false);
    };
    this.handleClear = e => {
      e && e.stopPropagation();
      this.foundation.handleClear();
    };
    /**
     * A11y: simulate clear button click
     */
    /* istanbul ignore next */
    this.handleClearEnterPress = e => {
      e && e.stopPropagation();
      this.foundation.handleClearEnterPress(e);
    };
    this.showClearBtn = () => {
      const {
        showClear,
        disabled,
        multiple
      } = this.props;
      const {
        selectedKeys,
        isOpen,
        isHovering,
        checkedKeys,
        inputValue
      } = this.state;
      const hasValue = selectedKeys.size;
      const multipleWithHaveValue = multiple && checkedKeys.size;
      return showClear && (inputValue || hasValue || multipleWithHaveValue) && !disabled && (isOpen || isHovering);
    };
    this.renderClearBtn = () => {
      const clearCls = (0, _classnames.default)(`${prefixcls}-clearbtn`);
      const {
        clearIcon
      } = this.props;
      const allowClear = this.showClearBtn();
      if (allowClear) {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: clearCls,
          onClick: this.handleClear,
          onKeyPress: this.handleClearEnterPress,
          role: "button",
          tabIndex: 0
        }, clearIcon ? clearIcon : /*#__PURE__*/_react.default.createElement(_semiIcons.IconClear, null));
      }
      return null;
    };
    this.renderArrow = () => {
      const {
        arrowIcon
      } = this.props;
      const showClearBtn = this.showClearBtn();
      if (showClearBtn) {
        return null;
      }
      return arrowIcon ? (/*#__PURE__*/_react.default.createElement("div", {
        className: (0, _classnames.default)(`${prefixcls}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, arrowIcon)) : null;
    };
    this.renderSelection = () => {
      const {
        disabled,
        multiple,
        filterTreeNode,
        style,
        size,
        className,
        validateStatus,
        prefix,
        suffix,
        insetLabel,
        triggerRender,
        showClear,
        id,
        borderless
      } = this.props;
      const {
        isOpen,
        isFocus,
        isInput,
        checkedKeys
      } = this.state;
      const filterable = Boolean(filterTreeNode);
      const useCustomTrigger = typeof triggerRender === 'function';
      const classNames = useCustomTrigger ? (0, _classnames.default)(className) : (0, _classnames.default)(prefixcls, className, {
        [`${prefixcls}-borderless`]: borderless,
        [`${prefixcls}-focus`]: isFocus || isOpen && !isInput,
        [`${prefixcls}-disabled`]: disabled,
        [`${prefixcls}-single`]: true,
        [`${prefixcls}-filterable`]: filterable,
        [`${prefixcls}-error`]: validateStatus === 'error',
        [`${prefixcls}-warning`]: validateStatus === 'warning',
        [`${prefixcls}-small`]: size === 'small',
        [`${prefixcls}-large`]: size === 'large',
        [`${prefixcls}-with-prefix`]: prefix || insetLabel,
        [`${prefixcls}-with-suffix`]: suffix
      });
      const mouseEvent = showClear ? {
        onMouseEnter: () => this.handleMouseOver(),
        onMouseLeave: () => this.handleMouseLeave()
      } : {};
      const sectionCls = (0, _classnames.default)(`${prefixcls}-selection`, {
        [`${prefixcls}-selection-multiple`]: multiple && !(0, _isEmpty2.default)(checkedKeys)
      });
      const inner = useCustomTrigger ? this.renderCustomTrigger() : [/*#__PURE__*/_react.default.createElement(_react.Fragment, {
        key: 'prefix'
      }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
        key: 'selection'
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: sectionCls
      }, this.renderSelectContent())), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
        key: 'suffix'
      }, suffix ? this.renderSuffix() : null), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
        key: 'clearbtn'
      }, this.renderClearBtn()), /*#__PURE__*/_react.default.createElement(_react.Fragment, {
        key: 'arrow'
      }, this.renderArrow())];
      /**
       * Reasons for disabling the a11y eslint rule:
       * The following attributes(aria-controls,aria-expanded) will be automatically added by Tooltip, no need to declare here
       */
      return /*#__PURE__*/_react.default.createElement("div", Object.assign({
        className: classNames,
        style: style,
        ref: this.triggerRef,
        onClick: e => this.foundation.handleClick(e),
        onKeyPress: e => this.foundation.handleSelectionEnterPress(e),
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-label": this.props['aria-label'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required'],
        id: id,
        onKeyDown: this.foundation.handleKeyDown
      }, mouseEvent, {
        // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
        role: "combobox",
        tabIndex: 0
      }, this.getDataAttr(this.props)), inner);
    };
    this.state = {
      disabledKeys: new Set(),
      isOpen: props.defaultOpen,
      /* By changing rePosKey, the dropdown position can be refreshed */
      rePosKey: resetkey,
      /* A data structure for storing cascader data items */
      keyEntities: {},
      /* Selected and show tick icon */
      selectedKeys: new Set([]),
      /* The key of the activated node */
      activeKeys: new Set([]),
      /* The key of the filtered node */
      filteredKeys: new Set([]),
      /* Value of input box */
      inputValue: '',
      /* Is searching */
      isSearching: false,
      /* The placeholder of input box */
      inputPlaceHolder: props.searchPlaceholder || props.placeholder,
      /* Cache props */
      prevProps: {},
      /* Is hovering */
      isHovering: false,
      /* Key of checked node, when multiple */
      checkedKeys: new Set([]),
      /* Key of half checked node, when multiple */
      halfCheckedKeys: new Set([]),
      /* Auto merged checkedKeys or leaf checkedKeys, when multiple */
      resolvedCheckedKeys: new Set([]),
      /* Keys of loaded item */
      loadedKeys: new Set(),
      /* Keys of loading item */
      loadingKeys: new Set(),
      /* Mark whether this rendering has triggered asynchronous loading of data */
      loading: false,
      showInput: false
    };
    this.options = {};
    this.isEmpty = false;
    this.mergeType = (0, _util.calcMergeType)(props.autoMergeValue, props.leafOnly);
    this.inputRef = /*#__PURE__*/_react.default.createRef();
    this.triggerRef = /*#__PURE__*/_react.default.createRef();
    this.optionsRef = /*#__PURE__*/_react.default.createRef();
    this.clickOutsideHandler = null;
    this.foundation = new _foundation.default(this.adapter);
    this.loadingKeysRef = /*#__PURE__*/_react.default.createRef();
    this.loadedKeysRef = /*#__PURE__*/_react.default.createRef();
  }
  get adapter() {
    var _this = this;
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      updateInputPlaceHolder: value => {
        this.setState({
          inputPlaceHolder: value
        });
      },
      focusInput: () => {
        const {
          preventScroll
        } = this.props;
        if (this.inputRef && this.inputRef.current) {
          // TODO: check the reason
          this.inputRef.current.focus({
            preventScroll
          });
        }
      },
      blurInput: () => {
        if (this.inputRef && this.inputRef.current) {
          this.inputRef.current.blur();
        }
      }
    };
    const cascaderAdapter = {
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current;
          const optionsDom = _reactDom.default.findDOMNode(optionInstance);
          const target = e.target;
          const path = e.composedPath && e.composedPath() || [target];
          if (optionsDom && (!optionsDom.contains(target) || !optionsDom.contains(target.parentNode)) && triggerDom && !triggerDom.contains(target) && !(path.includes(triggerDom) || path.includes(optionsDom))) {
            cb(e);
          }
        };
        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        document.removeEventListener('mousedown', this.clickOutsideHandler, false);
      },
      rePositionDropdown: () => {
        let {
          rePosKey
        } = this.state;
        rePosKey = rePosKey + 1;
        this.setState({
          rePosKey
        });
      }
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), filterAdapter), cascaderAdapter), {
      updateStates: states => {
        this.setState(Object.assign({}, states));
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        });
      },
      closeMenu: cb => {
        this.setState({
          isOpen: false
        }, () => {
          cb && cb();
        });
      },
      updateSelection: selectedKeys => this.setState({
        selectedKeys
      }),
      notifyChange: value => {
        this.props.onChange && this.props.onChange(value);
      },
      notifySelect: selected => {
        this.props.onSelect && this.props.onSelect(selected);
      },
      notifyOnSearch: input => {
        this.props.onSearch && this.props.onSearch(input);
      },
      notifyFocus: function () {
        _this.props.onFocus && _this.props.onFocus(...arguments);
      },
      notifyBlur: function () {
        _this.props.onBlur && _this.props.onBlur(...arguments);
      },
      notifyDropdownVisibleChange: visible => {
        this.props.onDropdownVisibleChange(visible);
      },
      toggleHovering: bool => {
        this.setState({
          isHovering: bool
        });
      },
      notifyLoadData: (selectedOpt, callback) => {
        const {
          loadData
        } = this.props;
        if (loadData) {
          new Promise(resolve => {
            loadData(selectedOpt).then(() => {
              /** Why update loading status & call callback function in setTimeout?
               *  loadData func will update treeData, treeData change may trigger
               *  selectedKeys & activeKeys change. For Loading data asynchronously，
               *  activeKeys should not change， Its implementation depends on loading
               *  & loadedKeys. The update time of Loading & loadedKeys(in callback func)
               *  should be later than the update time of treeData(in loaData func)
               *  In React 18, we need to use setTimeout to ensure the above time requirements.
               * */
              setTimeout(() => {
                callback();
                this.setState({
                  loading: false
                });
                resolve();
              });
            });
          });
        }
      },
      notifyOnLoad: (newLoadedKeys, data) => {
        const {
          onLoad
        } = this.props;
        onLoad && onLoad(newLoadedKeys, data);
      },
      notifyListScroll: (e, _ref) => {
        let {
          panelIndex,
          activeNode
        } = _ref;
        this.props.onListScroll(e, {
          panelIndex,
          activeNode
        });
      },
      notifyOnExceed: data => this.props.onExceed(data),
      notifyClear: () => this.props.onClear(),
      toggleInputShow: (showInput, cb) => {
        this.setState({
          showInput
        }, () => {
          cb();
        });
      },
      updateFocusState: isFocus => {
        this.setState({
          isFocus
        });
      },
      updateLoadingKeyRefValue: keys => {
        this.loadingKeysRef.current = keys;
      },
      getLoadingKeyRefValue: () => {
        return this.loadingKeysRef.current;
      },
      updateLoadedKeyRefValue: keys => {
        this.loadedKeysRef.current = keys;
      },
      getLoadedKeyRefValue: () => {
        return this.loadedKeysRef.current;
      }
    });
  }
  static getDerivedStateFromProps(props, prevState) {
    const {
      multiple,
      value,
      defaultValue,
      onChangeWithObject,
      leafOnly,
      autoMergeValue
    } = props;
    const {
      prevProps
    } = prevState;
    let keyEntities = prevState.keyEntities || {};
    const newState = {};
    const needUpdate = name => {
      const firstInProps = (0, _isEmpty2.default)(prevProps) && name in props;
      const nameHasChange = prevProps && !(0, _isEqual2.default)(prevProps[name], props[name]);
      return firstInProps || nameHasChange;
    };
    const needUpdateData = () => {
      const firstInProps = !prevProps && 'treeData' in props;
      const treeDataHasChange = prevProps && prevProps.treeData !== props.treeData;
      return firstInProps || treeDataHasChange;
    };
    const getRealKeys = (realValue, keyEntities) => {
      // normalizedValue is used to save the value in two-dimensional array format
      let normalizedValue = [];
      if (Array.isArray(realValue)) {
        normalizedValue = Array.isArray(realValue[0]) ? realValue : [realValue];
      } else {
        if (realValue !== undefined) {
          normalizedValue = [[realValue]];
        }
      }
      // formatValuePath is used to save value of valuePath
      const formatValuePath = [];
      normalizedValue.forEach(valueItem => {
        const formatItem = onChangeWithObject && (0, _isObject2.default)(valueItem[0]) ? valueItem.map(i => i === null || i === void 0 ? void 0 : i.value) : valueItem;
        formatItem.length > 0 && formatValuePath.push(formatItem);
      });
      // formatKeys is used to save key of value
      const formatKeys = formatValuePath.reduce((acc, cur) => {
        const key = (0, _util.getKeyByValuePath)(cur);
        keyEntities[key] && acc.push(key);
        return acc;
      }, []);
      return formatKeys;
    };
    if (multiple) {
      const needUpdateTreeData = needUpdate('treeData') || needUpdateData();
      const needUpdateValue = needUpdate('value') || (0, _isEmpty2.default)(prevProps) && defaultValue;
      // when value and treedata need updated
      if (needUpdateTreeData || needUpdateValue) {
        // update state.keyEntities
        if (needUpdateTreeData) {
          newState.treeData = props.treeData;
          keyEntities = (0, _util.convertDataToEntities)(props.treeData);
          newState.keyEntities = keyEntities;
        }
        let realKeys = prevState.checkedKeys;
        // when data was updated
        if (needUpdateValue) {
          const realValue = needUpdate('value') ? value : defaultValue;
          realKeys = getRealKeys(realValue, keyEntities);
        } else {
          // needUpdateValue is false
          // if treeData is updated & Cascader is controlled, realKeys should be recalculated
          if (needUpdateTreeData && 'value' in props) {
            const realValue = value;
            realKeys = getRealKeys(realValue, keyEntities);
          }
        }
        if ((0, _isSet2.default)(realKeys)) {
          realKeys = [...realKeys];
        }
        const calRes = (0, _treeUtil.calcCheckedKeys)(realKeys, keyEntities);
        const checkedKeys = new Set(calRes.checkedKeys);
        const halfCheckedKeys = new Set(calRes.halfCheckedKeys);
        // disableStrictly
        if (props.disableStrictly) {
          newState.disabledKeys = (0, _treeUtil.calcDisabledKeys)(keyEntities);
        }
        const isLeafOnlyMerge = (0, _util.calcMergeType)(autoMergeValue, leafOnly) === _constants.strings.LEAF_ONLY_MERGE_TYPE;
        newState.prevProps = props;
        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
        newState.resolvedCheckedKeys = new Set((0, _treeUtil.normalizeKeyList)(checkedKeys, keyEntities, isLeafOnlyMerge));
      }
    }
    return newState;
  }
  componentDidMount() {
    this.foundation.init();
  }
  componentWillUnmount() {
    this.foundation.destroy();
  }
  componentDidUpdate(prevProps) {
    if (this.props.multiple) {
      return;
    }
    let isOptionsChanged = false;
    if (!(0, _isEqual2.default)(prevProps.treeData, this.props.treeData)) {
      isOptionsChanged = true;
      this.foundation.collectOptions();
    }
    if (prevProps.value !== this.props.value && !isOptionsChanged) {
      this.foundation.handleValueChange(this.props.value);
    }
  }
  renderTagInput() {
    const {
      size,
      disabled,
      placeholder,
      maxTagCount,
      showRestTagsPopover,
      restTagsPopoverProps
    } = this.props;
    const {
      inputValue,
      checkedKeys,
      keyEntities,
      resolvedCheckedKeys
    } = this.state;
    const tagInputcls = (0, _classnames.default)(`${prefixcls}-tagInput-wrapper`);
    const realKeys = this.mergeType === _constants.strings.NONE_MERGE_TYPE ? checkedKeys : resolvedCheckedKeys;
    return /*#__PURE__*/_react.default.createElement(_tagInput.default, {
      className: tagInputcls,
      ref: this.inputRef,
      disabled: disabled,
      size: size,
      value: [...realKeys],
      showRestTagsPopover: showRestTagsPopover,
      restTagsPopoverProps: restTagsPopoverProps,
      maxTagCount: maxTagCount,
      renderTagItem: this.renderTagItem,
      inputValue: inputValue,
      onInputChange: this.handleInputChange,
      // TODO Modify logic, not modify type
      onRemove: this.onRemoveInTagInput,
      placeholder: placeholder,
      expandRestTagsOnClick: false
    });
  }
  renderInput() {
    const {
      size,
      disabled
    } = this.props;
    const inputcls = (0, _classnames.default)(`${prefixcls}-input`);
    const {
      inputValue,
      inputPlaceHolder,
      showInput
    } = this.state;
    const inputProps = {
      disabled,
      value: inputValue,
      className: inputcls,
      onChange: this.handleInputChange
    };
    const wrappercls = (0, _classnames.default)({
      [`${prefixcls}-search-wrapper`]: true,
      [`${prefixcls}-search-wrapper-${size}`]: size !== 'default'
    });
    const displayText = this.renderDisplayText();
    const spanCls = (0, _classnames.default)({
      [`${prefixcls}-selection-placeholder`]: !displayText,
      [`${prefixcls}-selection-text-hide`]: showInput && inputValue,
      [`${prefixcls}-selection-text-inactive`]: showInput && !inputValue
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      className: wrappercls
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: spanCls
    }, displayText ? displayText : inputPlaceHolder), showInput && /*#__PURE__*/_react.default.createElement(_index.default, Object.assign({
      ref: this.inputRef,
      size: size
    }, inputProps)));
  }
  close() {
    this.foundation.close();
  }
  open() {
    this.foundation.open();
  }
  focus() {
    this.foundation.focus();
  }
  blur() {
    this.foundation.blur();
  }
  render() {
    const {
      zIndex,
      getPopupContainer,
      autoAdjustOverflow,
      stopPropagation,
      mouseLeaveDelay,
      mouseEnterDelay,
      position,
      motion,
      dropdownMargin
    } = this.props;
    const {
      isOpen,
      rePosKey
    } = this.state;
    const {
      direction
    } = this.context;
    const content = this.renderContent();
    const selection = this.renderSelection();
    const pos = position !== null && position !== void 0 ? position : direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    return /*#__PURE__*/_react.default.createElement(_index2.default, {
      getPopupContainer: getPopupContainer,
      zIndex: zIndex,
      motion: motion,
      margin: dropdownMargin,
      ref: this.optionsRef,
      content: content,
      visible: isOpen,
      trigger: "custom",
      rePosKey: rePosKey,
      position: pos,
      autoAdjustOverflow: autoAdjustOverflow,
      stopPropagation: stopPropagation,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      afterClose: () => this.foundation.updateSearching(false)
    }, selection);
  }
}
Cascader.__SemiComponentName__ = "Cascader";
Cascader.contextType = _context.default;
Cascader.propTypes = {
  'aria-labelledby': _propTypes.default.string,
  'aria-invalid': _propTypes.default.bool,
  'aria-errormessage': _propTypes.default.string,
  'aria-describedby': _propTypes.default.string,
  'aria-required': _propTypes.default.bool,
  'aria-label': _propTypes.default.string,
  arrowIcon: _propTypes.default.node,
  borderless: _propTypes.default.bool,
  clearIcon: _propTypes.default.node,
  changeOnSelect: _propTypes.default.bool,
  defaultValue: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array]),
  disabled: _propTypes.default.bool,
  dropdownClassName: _propTypes.default.string,
  dropdownStyle: _propTypes.default.object,
  dropdownMargin: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.object]),
  emptyContent: _propTypes.default.node,
  motion: _propTypes.default.bool,
  /* show search input, if passed in a function, used as custom filter */
  filterTreeNode: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),
  filterLeafOnly: _propTypes.default.bool,
  placeholder: _propTypes.default.string,
  searchPlaceholder: _propTypes.default.string,
  size: _propTypes.default.oneOf(_constants.strings.SIZE_SET),
  style: _propTypes.default.object,
  className: _propTypes.default.string,
  treeData: _propTypes.default.arrayOf(_propTypes.default.shape({
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
    label: _propTypes.default.any
  })),
  treeNodeFilterProp: _propTypes.default.string,
  suffix: _propTypes.default.node,
  prefix: _propTypes.default.node,
  insetLabel: _propTypes.default.node,
  insetLabelId: _propTypes.default.string,
  id: _propTypes.default.string,
  displayProp: _propTypes.default.string,
  displayRender: _propTypes.default.func,
  onChange: _propTypes.default.func,
  onSearch: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  onBlur: _propTypes.default.func,
  onFocus: _propTypes.default.func,
  children: _propTypes.default.node,
  getPopupContainer: _propTypes.default.func,
  zIndex: _propTypes.default.number,
  value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number, _propTypes.default.array]),
  validateStatus: _propTypes.default.oneOf(_constants.strings.VALIDATE_STATUS),
  showNext: _propTypes.default.oneOf([_constants.strings.SHOW_NEXT_BY_CLICK, _constants.strings.SHOW_NEXT_BY_HOVER]),
  stopPropagation: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  showClear: _propTypes.default.bool,
  defaultOpen: _propTypes.default.bool,
  autoAdjustOverflow: _propTypes.default.bool,
  onDropdownVisibleChange: _propTypes.default.func,
  triggerRender: _propTypes.default.func,
  onListScroll: _propTypes.default.func,
  onChangeWithObject: _propTypes.default.bool,
  bottomSlot: _propTypes.default.node,
  topSlot: _propTypes.default.node,
  multiple: _propTypes.default.bool,
  autoMergeValue: _propTypes.default.bool,
  maxTagCount: _propTypes.default.number,
  showRestTagsPopover: _propTypes.default.bool,
  restTagsPopoverProps: _propTypes.default.object,
  max: _propTypes.default.number,
  separator: _propTypes.default.string,
  onExceed: _propTypes.default.func,
  onClear: _propTypes.default.func,
  loadData: _propTypes.default.func,
  onLoad: _propTypes.default.func,
  loadedKeys: _propTypes.default.array,
  disableStrictly: _propTypes.default.bool,
  leafOnly: _propTypes.default.bool,
  enableLeafClick: _propTypes.default.bool,
  preventScroll: _propTypes.default.bool,
  position: _propTypes.default.string,
  searchPosition: _propTypes.default.string
};
Cascader.defaultProps = (0, _utils.getDefaultPropsFromGlobalConfig)(Cascader.__SemiComponentName__, {
  borderless: false,
  leafOnly: false,
  arrowIcon: /*#__PURE__*/_react.default.createElement(_semiIcons.IconChevronDown, null),
  stopPropagation: true,
  motion: true,
  defaultOpen: false,
  zIndex: _constants2.numbers.DEFAULT_Z_INDEX,
  showClear: false,
  autoClearSearchValue: true,
  changeOnSelect: false,
  disableStrictly: false,
  autoMergeValue: true,
  multiple: false,
  filterTreeNode: false,
  filterLeafOnly: true,
  showRestTagsPopover: false,
  restTagsPopoverProps: {},
  separator: ' / ',
  size: 'default',
  treeNodeFilterProp: 'label',
  displayProp: 'label',
  treeData: [],
  showNext: _constants.strings.SHOW_NEXT_BY_CLICK,
  onExceed: _noop2.default,
  onClear: _noop2.default,
  onDropdownVisibleChange: _noop2.default,
  onListScroll: _noop2.default,
  enableLeafClick: false,
  'aria-label': 'Cascader',
  searchPosition: _constants.strings.SEARCH_POSITION_TRIGGER
});
var _default = exports.default = Cascader;